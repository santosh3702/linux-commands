pwd - present working directory.
cd - change directory.
ls - list of directoryies.
mkdir - make directory
touch - to create a file.
vi - is editor
    1. open file with vi 
    2. to edit we need to go to insert mode for that we need to press "i"
    3. update the file by writing something
    4. to save and come out of editor mode press "Esc" will come out of insert mode and then we need to press ":wq!" for saving. ":q" for not saving
cat - is for viewing
rm - to delete a file or a directory we use '-rf' 
rmdir - to delte directory.
cp - to copy files one place to another place or rename of a filr or a directory
mv - to move files from one place to another place or rename of a filr or a directory

----------------------------------------

4 stands for "read",
2 stands for "write",
1 stands for "execute", and
0 stands for "no permission."

-rw       |     r         |   r
 owner per | group permition | others permission 
 
 chmod 777 
 -------------------
 root@ErsJumpserver1:~# ls -ltr | grep test
-rw-r--r-- 1 root root         0 Nov  5 05:18 test.txt
root@ErsJumpserver1:~# chgrp -R ersdevops test.txt
root@ErsJumpserver1:~# ls -ltr | grep test
-rw-r--r-- 1 root ersdevops        0 Nov  5 05:18 test.txt
root@ErsJumpserver1:~# chown -R ersdevops test.txt
root@ErsJumpserver1:~# ls -ltr | grep test
-rw-r--r-- 1 ersdevops ersdevops        0 Nov  5 05:18 test.txt
root@ErsJumpserver1:~# vi test.txt
 ----------------
 loops;
   for
   while 
   do while
 switch case 
 Conditions;
   if 
   if else 
   if elseif else
   
 functions();
 
 ------------
 Steve Bourne wrote the Bourne shell which appeared in the Seventh Edition Bell Labs Research version of Unix.
Many other shells have been written; this particular tutorial concentrates on the Bourne and the Bourne Again shells.
Other shells include the Korn Shell (ksh), the C Shell (csh), and variations such as tcsh.
This tutorial does not cover those shells.

------

#!/bin/sh
# This is a comment!
echo Hello World 

The first line tells Unix that the file is to be executed by /bin/sh. This is the standard location of the Bourne shell on just about every Unix system.

The second line begins with a special symbol: #. This marks the line as a comment, and it is ignored completely by the shell.

The only exception is when the very first line of the file starts with #! - as ours does. This is a special directive which Unix treats specially. It means that even if you are using csh, ksh, or anything else as your interactive shell, that what follows should be interpreted by the Bourne shell.
Similarly, a Perl script may start with the line #!/usr/bin/perl to tell your interactive shell that the program which follows should be executed by perl. For Bourne shell programming, we shall stick to #!/bin/sh.

Variables :-

#!/bin/sh
MY_MESSAGE="Hello World"
echo $MY_MESSAGE

The shell does not care about types of variables; they may store strings, integers, real numbers - anything you like.

MY_MESSAGE="Hello World"
MY_SHORT_MESSAGE=hi
MY_NUMBER=1
MY_PI=3.142
MY_OTHER_PI="3.142"
MY_MIXED=123abc

We can interactively set variable names using the read command; the following script asks you for your name then greets you personally:

#!/bin/sh
echo What is your name?
read MY_NAME
echo "Hello $MY_NAME - hope you're well."


-----
#!/bin/sh
echo "What is your name?"
read USER_NAME
echo "Hello $USER_NAME"
echo "I will create you a file called $USER_NAME_file"
touch $USER_NAME_file

-----

#!/bin/sh
echo "What is your name?"
read USER_NAME
echo "Hello $USER_NAME"
echo "I will create you a file called ${USER_NAME}_file"
touch "${USER_NAME}_file"

-----
Loops:

Most languages have the concept of loops: If we want to repeat a task twenty times, we don't want to have to type in the code twenty times, with maybe a slight change each time.
As a result, we have for and while loops in the Bourne shell. 

for loop

for loops iterate through a set of values until the list is exhausted

For example, you can run UNIX command or task 5 times or read and process list of files using a for loop.

for loop syntax

for VARIABLE in 1 2 3 4 5 .. N
do
	command1
	command2
	commandN
done

or

for VARIABLE in file1 file2 file3
do
	command1 on $VARIABLE
	command2
	commandN
done

or

for OUTPUT in $(Linux-Or-Unix-Command-Here)
do
	command1 on $OUTPUT
	command2 on $OUTPUT
	commandN
done

Examples:

#!/bin/bash
for i in 1 2 3 4 5
do
   echo "Welcome $i times"
done

#!/bin/bash
for i in {1..5}
do
   echo "Welcome $i times"
done

Bash v4.0+ has inbuilt support for setting up a step value using {START..END..INCREMENT} syntax:

#!/bin/bash
echo "Bash version ${BASH_VERSION}..."
for i in {0..10..2}
  do 
     echo "Welcome $i times"
 done
 
 Three-expression bash for loops syntax
 
 for (( EXP1; EXP2; EXP3 ))
do
	command1
	command2
	command3
done

#!/bin/bash
for (( c=1; c<=5; c++ ))
do  
   echo "Welcome $c times"
done

How do I use for as infinite loops?

Syntax:

#!/bin/bash
for (( ; ; ))
do
   echo "infinite loops [ hit CTRL+C to stop]"
done

Conditional exit with break

You can do early exit with break statement inside the for loop. You can exit from within a FOR, WHILE or UNTIL loop using break. General break statement inside the for loop:

Syntax:

for I in 1 2 3 4 5
do
  statements1      #Executed for all values of ''I'', up to a disaster-condition if any.
  statements2
  if (disaster-condition)
  then
	break       	   #Abandon the loop.
  fi
  statements3          #While good and, no disaster-condition.
done

Example:

#!/bin/bash
for file in /etc/*
do
	if [ "${file}" == "/etc/resolv.conf" ]
	then
		countNameservers=$(grep -c nameserver /etc/resolv.conf)
		echo "Total  ${countNameservers} nameservers defined in ${file}"
		break
	fi
done

Early continuation with continue statement

To resume the next iteration of the enclosing FOR, WHILE or UNTIL loop use continue statement.

Syntax:

for I in 1 2 3 4 5
do
  statements1      #Executed for all values of ''I'', up to a disaster-condition if any.
  statements2
  if (condition)
  then
	continue   #Go to next iteration of I in the loop and skip statements3
  fi
  statements3
done

Example
#!/bin/bash
FILES="$@"
for f in $FILES
do
        # if .bak backup file exists, read next file
	if [ -f ${f}.bak ]
	then
		echo "Skiping $f file..."
		continue  # read next file and skip the cp command
	fi
        # we are here means no backup file exists, just use cp command to copy file
	/bin/cp $f $f.bak
done

-----


#!/bin/sh
# A simple script with a function...

add_a_user()
{
  USER=$1
  PASSWORD=$2
  shift; shift;
  # Having shifted twice, the rest is now comments ...
  COMMENTS=$@
  echo "Adding user $USER ..."
  echo useradd -c "$COMMENTS" $USER
  echo passwd $USER $PASSWORD
  echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}

###
# Main body of script starts here
###
echo "Start of script..."
add_a_user bob letmein Bob Holness the presenter
add_a_user fred badpassword Fred Durst the singer
add_a_user bilko worsepassword Sgt. Bilko the role model
echo "End of script..."

------

#!/bin/sh

myfunc()
{
  echo "I was called as : $@"
  x=2
}

### Main script starts here 

echo "Script was called with $@"
x=1
echo "x is $x"
myfunc 1 2 3
echo "x is $x"

